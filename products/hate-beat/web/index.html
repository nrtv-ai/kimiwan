<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Hate Beat</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            color: #fff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        /* Safe area insets for notched devices */
        .safe-area {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        
        .screen {
            display: none;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            min-height: 100vh;
            min-height: 100dvh;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .screen.active { display: flex; }
        h1 {
            text-align: center;
            font-size: clamp(2rem, 8vw, 3.5rem);
            margin-bottom: 10px;
            text-shadow: 0 0 20px #e94560, 0 0 40px #e94560;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: clamp(0.9rem, 4vw, 1.2rem);
            padding: 0 20px;
        }
        
        /* Mobile-optimized inputs */
        input, textarea {
            width: 100%;
            max-width: 400px;
            padding: 15px;
            border: 2px solid #e94560;
            border-radius: 10px;
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 16px; /* Prevents zoom on iOS */
            margin-bottom: 20px;
            outline: none;
            transition: box-shadow 0.3s;
            -webkit-appearance: none;
            appearance: none;
        }
        input:focus, textarea:focus {
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        input::placeholder, textarea::placeholder {
            color: #666;
        }
        
        /* Mobile-optimized buttons */
        button {
            background: linear-gradient(135deg, #e94560 0%, #ff6b6b 100%);
            border: none;
            padding: 18px 45px; /* Larger touch target */
            border-radius: 30px;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
            min-height: 56px; /* Minimum touch target size */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        button:hover, button:active {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.6);
        }
        button:disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Hate scale - mobile optimized */
        .hate-scale {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            max-width: 400px;
        }
        .hate-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid #e94560;
            background: transparent;
            color: #fff;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            min-width: 48px;
        }
        .hate-btn.selected {
            background: linear-gradient(135deg, #e94560 0%, #ff6b6b 100%);
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.6);
        }
        .hate-btn:active {
            transform: scale(0.95);
        }
        
        /* Game Canvas */
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: none;
            touch-action: none;
        }
        #gameCanvas.active { display: block; }
        
        /* UI Overlay - with safe area */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            padding-top: max(15px, env(safe-area-inset-top));
            padding-left: max(15px, env(safe-area-inset-left));
            padding-right: max(15px, env(safe-area-inset-right));
            z-index: 10;
            pointer-events: none;
            display: none;
        }
        .ui-overlay.active { display: block; }
        
        .hp-bar {
            width: 100%;
            height: 25px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 8px;
            border: 2px solid rgba(233, 69, 96, 0.3);
        }
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560 0%, #ff6b6b 100%);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }
        .word-counter {
            text-align: center;
            font-size: 1rem;
            color: #aaa;
        }
        
        /* Score display - positioned for safe area */
        .score-display {
            position: fixed;
            top: max(60px, env(safe-area-inset-top) + 45px);
            right: max(15px, env(safe-area-inset-right));
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ecca3;
            text-shadow: 0 0 10px #4ecca3;
            z-index: 10;
            pointer-events: none;
        }
        .combo-display {
            position: fixed;
            top: max(90px, env(safe-area-inset-top) + 75px);
            right: max(15px, env(safe-area-inset-right));
            font-size: 1rem;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .combo-display.active { opacity: 1; }
        
        /* Beat indicator */
        .beat-indicator {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #e94560;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .beat-indicator.active {
            opacity: 1;
            animation: beatPulse 0.5s ease-out;
        }
        @keyframes beatPulse {
            0% { transform: translateX(-50%) scale(1); box-shadow: 0 0 0 rgba(233, 69, 96, 0.8); }
            50% { transform: translateX(-50%) scale(1.3); box-shadow: 0 0 30px rgba(233, 69, 96, 0.8); }
            100% { transform: translateX(-50%) scale(1); box-shadow: 0 0 0 rgba(233, 69, 96, 0); }
        }
        
        /* Rhythm bar */
        .rhythm-bar {
            position: fixed;
            bottom: max(80px, env(safe-area-inset-bottom) + 60px);
            left: 50%;
            transform: translateX(-50%);
            width: min(200px, 60vw);
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .rhythm-bar.active { opacity: 1; }
        .rhythm-marker {
            position: absolute;
            top: 0;
            width: 20px;
            height: 100%;
            background: #e94560;
            border-radius: 5px;
            animation: rhythmMove 2s linear infinite;
        }
        @keyframes rhythmMove {
            0% { left: -20px; }
            100% { left: 100%; }
        }
        
        /* Tutorial */
        .tutorial {
            position: fixed;
            bottom: max(100px, env(safe-area-inset-bottom) + 80px);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 90vw;
        }
        .tutorial.active { opacity: 1; }
        
        /* Floating text */
        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.2rem;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 20;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
        .perfect { color: #ffd700; text-shadow: 0 0 10px #ffd700; }
        .good { color: #4ecca3; text-shadow: 0 0 10px #4ecca3; }
        .miss { color: #e94560; text-shadow: 0 0 10px #e94560; }
        
        /* Victory/Game Over screens */
        .victory-screen, .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }
        .victory-screen.active, .game-over-screen.active { display: flex; }
        .victory-text {
            font-size: clamp(2.5rem, 10vw, 4rem);
            color: #4ecca3;
            text-shadow: 0 0 30px #4ecca3;
            margin-bottom: 20px;
            animation: victoryPulse 1s ease-in-out infinite;
        }
        .game-over-text {
            font-size: clamp(2.5rem, 10vw, 4rem);
            color: #e94560;
            text-shadow: 0 0 30px #e94560;
            margin-bottom: 20px;
        }
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); text-shadow: 0 0 30px #4ecca3; }
            50% { transform: scale(1.05); text-shadow: 0 0 50px #4ecca3, 0 0 70px #4ecca3; }
        }
        
        .stats-box {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            border: 1px solid rgba(233, 69, 96, 0.3);
            max-width: 90vw;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 1.1rem;
        }
        
        /* High scores */
        .high-score-badge {
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 15px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }
        .high-scores-list {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            max-width: 350px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .high-score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
        }
        .high-score-item:last-child { border-bottom: none; }
        .high-score-rank { color: #ffd700; font-weight: bold; width: 30px; }
        .high-score-task { flex: 1; text-align: left; padding: 0 10px; color: #aaa; }
        .high-score-points { color: #4ecca3; font-weight: bold; }
        
        /* Sound toggle - positioned for safe area */
        .sound-toggle {
            position: fixed;
            top: max(15px, env(safe-area-inset-top));
            right: max(15px, env(safe-area-inset-right));
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(233, 69, 96, 0.3);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            font-size: 1.2rem;
            min-height: 48px;
            min-width: 48px;
        }
        .sound-toggle:hover, .sound-toggle:active {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
        
        /* Pause button for mobile */
        .pause-btn {
            position: fixed;
            top: max(15px, env(safe-area-inset-top));
            left: max(15px, env(safe-area-inset-left));
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(233, 69, 96, 0.3);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            font-size: 1.2rem;
            min-height: 48px;
            min-width: 48px;
            pointer-events: auto;
        }
        .pause-btn:hover, .pause-btn:active {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
        
        /* Pause menu */
        .pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 20px;
        }
        .pause-menu.active { display: flex; }
        .pause-menu h2 {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #e94560;
        }
        .pause-menu button {
            margin: 10px 0;
            min-width: 200px;
        }
        
        /* Performance indicator (debug) */
        .fps-counter {
            position: fixed;
            top: max(70px, env(safe-area-inset-top) + 55px);
            left: max(15px, env(safe-area-inset-left));
            font-size: 0.8rem;
            color: #666;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
        }
        .fps-counter.active { opacity: 1; }
        
        /* Level Selection Grid */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            max-width: 400px;
            width: 100%;
            margin: 10px 0;
            max-height: 50vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 5px;
        }
        .level-card {
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.2) 0%, rgba(255, 107, 107, 0.1) 100%);
            border: 2px solid rgba(233, 69, 96, 0.4);
            border-radius: 12px;
            padding: 15px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .level-card:hover, .level-card:active {
            transform: scale(1.03);
            border-color: #e94560;
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.3) 0%, rgba(255, 107, 107, 0.2) 100%);
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.3);
        }
        .level-card.locked {
            opacity: 0.5;
            border-color: #444;
            background: rgba(255,255,255,0.05);
            cursor: not-allowed;
        }
        .level-card.locked .level-icon {
            filter: grayscale(1);
        }
        .level-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        .level-name {
            font-weight: bold;
            font-size: 0.95rem;
            color: #fff;
            margin-bottom: 4px;
        }
        .level-difficulty {
            font-size: 0.75rem;
            color: #888;
        }
        .level-stars {
            font-size: 0.8rem;
            color: #ffd700;
            margin-top: 4px;
        }
        
        /* Mobile-specific animations */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Landscape mode adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            h1 { font-size: 1.8rem; margin-bottom: 5px; }
            .subtitle { font-size: 0.8rem; margin-bottom: 15px; }
            input, textarea { padding: 10px; margin-bottom: 10px; }
            button { padding: 12px 30px; min-height: 44px; }
            .hate-scale { gap: 5px; }
            .hate-btn { width: 36px; height: 36px; min-width: 36px; min-height: 36px; }
        }
    </style>
</head>
<body>
    <!-- Sound Toggle -->
    <div class="sound-toggle" id="soundToggle" onclick="toggleSound()">üîä</div>
    
    <!-- Pause Button (game only) -->
    <div class="pause-btn" id="pauseBtn" onclick="togglePause()" style="display: none;">‚è∏Ô∏è</div>
    
    <!-- FPS Counter (debug) -->
    <div class="fps-counter" id="fpsCounter">FPS: 60</div>
    
    <!-- Screen 1: Task Input -->
    <div id="screen1" class="screen active">
        <h1>HATE BEAT</h1>
        <p class="subtitle">What task do you absolutely hate?</p>
        <div class="high-score-badge" id="highScoreBadge" style="display: none;">üèÜ High Score: <span id="highScoreValue">0</span></div>
        <div class="high-scores-list" id="highScoresList" style="display: none;"></div>
        <input type="text" id="taskInput" placeholder="e.g., doing taxes, cleaning dishes..." maxlength="50" autocomplete="off" autocorrect="off" autocapitalize="off">
        <button onclick="goToScreen2()">Continue ‚Üí</button>
    </div>

    <!-- Screen 2: Hate Level -->
    <div id="screen2" class="screen">
        <h1>HATE BEAT</h1>
        <p class="subtitle">How much do you hate <span id="taskName"></span>?</p>
        <div class="hate-scale">
            <button class="hate-btn" onclick="selectHate(1)">1</button>
            <button class="hate-btn" onclick="selectHate(2)">2</button>
            <button class="hate-btn" onclick="selectHate(3)">3</button>
            <button class="hate-btn" onclick="selectHate(4)">4</button>
            <button class="hate-btn" onclick="selectHate(5)">5</button>
            <button class="hate-btn" onclick="selectHate(6)">6</button>
            <button class="hate-btn" onclick="selectHate(7)">7</button>
            <button class="hate-btn" onclick="selectHate(8)">8</button>
            <button class="hate-btn" onclick="selectHate(9)">9</button>
            <button class="hate-btn" onclick="selectHate(10)">10</button>
        </div>
        <p id="hateLabel" style="text-align: center; color: #888; margin: 20px 0; min-height: 24px;"></p>
        <button onclick="goToScreen3()" id="continueBtn2" disabled>Continue ‚Üí</button>
    </div>

    <!-- Screen 3: Level Selection -->
    <div id="screen3" class="screen">
        <h1>HATE BEAT</h1>
        <p class="subtitle">Choose your battle:</p>
        <div class="level-grid" id="levelGrid"></div>
        <button onclick="showScreen('screenCustom')" style="margin-top: 20px; background: linear-gradient(135deg, #666 0%, #888 100%);">Custom Battle ‚Üí</button>
    </div>

    <!-- Screen 3b: Custom Battle -->
    <div id="screenCustom" class="screen">
        <h1>HATE BEAT</h1>
        <p class="subtitle">Describe your hate with words (they become enemies!):</p>
        <textarea id="hateWords" rows="4" placeholder="e.g., boring tedious painful soul-crushing miserable awful..." maxlength="200" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
        <button onclick="startBattle()">BATTLE!</button>
    </div>

    <!-- Game Screen -->
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay" id="uiOverlay">
        <div class="hp-bar">
            <div class="hp-fill" id="hpFill" style="width: 100%"></div>
        </div>
        <div class="word-counter">
            <span id="wordsRemaining">0</span> enemies remaining
        </div>
    </div>
    <div class="score-display" id="scoreDisplay">Score: 0</div>
    <div class="combo-display" id="comboDisplay">Combo: x0</div>
    <div class="beat-indicator" id="beatIndicator"></div>
    <div class="rhythm-bar" id="rhythmBar">
        <div class="rhythm-marker"></div>
    </div>
    <div class="tutorial" id="tutorial">Tap the words to destroy them!<br>Time your taps with the beat for bonus points!</div>

    <!-- Pause Menu -->
    <div class="pause-menu" id="pauseMenu">
        <h2>PAUSED</h2>
        <button onclick="resumeGame()">Resume</button>
        <button onclick="resetGame()">Quit to Menu</button>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen" class="victory-screen">
        <div class="victory-text">VICTORY!</div>
        <p style="font-size: 1.2rem; margin-bottom: 10px;">You defeated <span id="victoryTask"></span>!</p>
        <div class="stats-box">
            <div class="stat-row"><span>Final Score:</span><span id="finalScore">0</span></div>
            <div class="stat-row"><span>Max Combo:</span><span id="maxCombo">0</span></div>
            <div class="stat-row"><span>Perfect Hits:</span><span id="perfectHits">0</span></div>
            <div class="stat-row"><span>Accuracy:</span><span id="accuracy">0%</span></div>
        </div>
        <button onclick="resetGame()" style="margin-top: 20px;">Beat Another Task</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="game-over-screen">
        <div class="game-over-text">GAME OVER</div>
        <p style="font-size: 1.2rem; margin-bottom: 10px;">The hate consumed you...</p>
        <div class="stats-box">
            <div class="stat-row"><span>Final Score:</span><span id="gameOverScore">0</span></div>
            <div class="stat-row"><span>Enemies Destroyed:</span><span id="enemiesDestroyed">0</span></div>
        </div>
        <button onclick="resetGame()" style="margin-top: 20px;">Try Again</button>
    </div>

    <script src="mobile-bridge.js"></script>
    <script>
        // ============================================
        // MOBILE DETECTION & PERFORMANCE SETTINGS
        // ============================================
        const MobileUtils = {
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
            isAndroid: /Android/.test(navigator.userAgent),
            isLowEnd: navigator.hardwareConcurrency <= 4 || /Android 4|Android 5|Android 6/.test(navigator.userAgent),
            
            // Haptic feedback
            haptic(type = 'light') {
                if (window.navigator && window.navigator.vibrate) {
                    const patterns = {
                        light: 10,
                        medium: 20,
                        heavy: 30,
                        success: [10, 50, 10],
                        error: [30, 30, 30]
                    };
                    window.navigator.vibrate(patterns[type] || 10);
                }
                // iOS haptic via Capacitor
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Haptics) {
                    const haptics = window.Capacitor.Plugins.Haptics;
                    const types = {
                        light: 'light',
                        medium: 'medium',
                        heavy: 'heavy',
                        success: 'success',
                        error: 'error'
                    };
                    haptics.impact({ style: types[type] || 'light' });
                }
            },
            
            // Prevent zoom on double tap
            preventZoom() {
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, { passive: false });
            },
            
            // Handle visibility change (pause game)
            handleVisibility(gameState, pauseCallback) {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && gameState.isPlaying && !gameState.isPaused) {
                        pauseCallback();
                    }
                });
            },
            
            // Prevent pull-to-refresh on mobile
            preventPullToRefresh() {
                document.body.style.overscrollBehavior = 'none';
                document.addEventListener('touchmove', (e) => {
                    if (e.target === canvas || canvas.contains(e.target)) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
        };
        
        // Apply mobile optimizations
        MobileUtils.preventZoom();
        MobileUtils.preventPullToRefresh();
        
        // ============================================
        // LEVEL SYSTEM - Pre-made songs/battles
        // ============================================
        const LevelSystem = {
            levels: [
                {
                    id: 1,
                    name: "Monday Morning",
                    icon: "üò¥",
                    task: "Monday mornings",
                    difficulty: "Easy",
                    hateLevel: 3,
                    words: "tired sleepy exhausted dreadful boring miserable awful painful soul crushing endless",
                    beatInterval: 500,
                    unlocked: true
                },
                {
                    id: 2,
                    name: "Traffic Jam",
                    icon: "üöó",
                    task: "sitting in traffic",
                    difficulty: "Easy",
                    hateLevel: 4,
                    words: "stuck waiting honking frustrating endless pointless wasted time anger stress anxiety road rage",
                    beatInterval: 450,
                    unlocked: true
                },
                {
                    id: 3,
                    name: "Email Overload",
                    icon: "üìß",
                    task: "checking emails",
                    difficulty: "Medium",
                    hateLevel: 5,
                    words: "overwhelming endless notifications spam junk pointless replies urgent priority stress drowning",
                    beatInterval: 400,
                    unlocked: true
                },
                {
                    id: 4,
                    name: "Tax Season",
                    icon: "üí∏",
                    task: "doing taxes",
                    difficulty: "Medium",
                    hateLevel: 6,
                    words: "confusing complicated forms numbers deductions receipts headache painful stress anxiety nightmare",
                    beatInterval: 350,
                    unlocked: true
                },
                {
                    id: 5,
                    name: "Group Project",
                    icon: "üë•",
                    task: "group projects",
                    difficulty: "Hard",
                    hateLevel: 7,
                    words: "freeloaders lazy unresponsive chaos disorganized unfair slacking frustrating anger betrayal stress",
                    beatInterval: 300,
                    unlocked: false
                },
                {
                    id: 6,
                    name: "Public Speaking",
                    icon: "üé§",
                    task: "public speaking",
                    difficulty: "Hard",
                    hateLevel: 8,
                    words: "nervous sweating shaking anxiety terrifying embarrassing judgment staring panic dread horror",
                    beatInterval: 280,
                    unlocked: false
                },
                {
                    id: 7,
                    name: "Dentist Visit",
                    icon: "ü¶∑",
                    task: "going to the dentist",
                    difficulty: "Insane",
                    hateLevel: 9,
                    words: "drilling pain needles anxiety fear terror screaming discomfort numbness bills trauma nightmares",
                    beatInterval: 250,
                    unlocked: false
                },
                {
                    id: 8,
                    name: "Existential Dread",
                    icon: "üåå",
                    task: "existential dread",
                    difficulty: "NIGHTMARE",
                    hateLevel: 10,
                    words: "meaningless void emptiness insignificance mortality anxiety despair hopelessness darkness infinite endless suffering",
                    beatInterval: 200,
                    unlocked: false
                }
            ],
            
            async getUnlockedLevels() {
                const saved = await Storage.get('hatebeat_unlocked');
                if (saved) {
                    this.levels.forEach((level, i) => {
                        if (saved[i] !== undefined) level.unlocked = saved[i];
                    });
                }
                return this.levels;
            },
            
            async unlockNextLevel(completedLevelId) {
                const nextLevel = this.levels.find(l => l.id === completedLevelId + 1);
                if (nextLevel && !nextLevel.unlocked) {
                    nextLevel.unlocked = true;
                    await this.saveProgress();
                    return nextLevel;
                }
                return null;
            },
            
            async saveProgress() {
                const unlocked = this.levels.map(l => l.unlocked);
                await Storage.set('hatebeat_unlocked', unlocked);
            },
            
            getLevel(id) {
                return this.levels.find(l => l.id === id);
            },
            
            renderGrid() {
                const grid = document.getElementById('levelGrid');
                if (!grid) return;
                
                grid.innerHTML = this.levels.map(level => `
                    <div class="level-card ${level.unlocked ? '' : 'locked'}" 
                         onclick="${level.unlocked ? `selectLevel(${level.id})` : ''}"
                         style="${!level.unlocked ? 'pointer-events: none;' : ''}">
                        <div class="level-icon">${level.unlocked ? level.icon : 'üîí'}</div>
                        <div class="level-name">${level.name}</div>
                        <div class="level-difficulty">${level.difficulty}</div>
                        ${level.unlocked ? `<div class="level-stars">${'‚òÖ'.repeat(Math.min(level.hateLevel, 5))}</div>` : ''}
                    </div>
                `).join('');
            }
        };
        
        // ============================================
        // GAME STATE
        // ============================================
        let gameState = {
            task: '',
            hateLevel: 0,
            words: [],
            enemies: [],
            particles: [],
            floatingTexts: [],
            wordsDestroyed: 0,
            totalWords: 0,
            score: 0,
            combo: 0,
            maxCombo: 0,
            perfectHits: 0,
            totalHits: 0,
            lastBeatTime: 0,
            beatInterval: 500,
            isPlaying: false,
            isPaused: false,
            gameTime: 0,
            soundEnabled: true,
            fps: 60,
            frameCount: 0,
            lastFpsTime: 0
        };

        // ============================================
        // AUDIO SYSTEM - Web Audio API
        // ============================================
        const AudioSys = {
            ctx: null,
            enabled: true,
            
            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    // iOS requires user interaction to start audio context
                    if (this.ctx.state === 'suspended') {
                        this.ctx.resume();
                    }
                } catch(e) {
                    console.log('Web Audio not supported');
                    this.enabled = false;
                }
            },
            
            playTone(freq, duration, type = 'sine', volume = 0.3) {
                if (!this.enabled || !this.ctx) return;
                if (this.ctx.state === 'suspended') this.ctx.resume();
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            
            playHit() { this.playTone(440, 0.1, 'square', 0.2); },
            playPerfect() {
                this.playTone(880, 0.15, 'sine', 0.3);
                setTimeout(() => this.playTone(1100, 0.2, 'sine', 0.2), 50);
            },
            playGood() { this.playTone(660, 0.12, 'sine', 0.25); },
            playMiss() { this.playTone(220, 0.2, 'sawtooth', 0.15); },
            playDestroy() {
                this.playTone(550, 0.1, 'square', 0.2);
                setTimeout(() => this.playTone(330, 0.15, 'sine', 0.15), 80);
            },
            playBeat() { this.playTone(80, 0.05, 'sine', 0.1); },
            playVictory() {
                [440, 554, 659, 880].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.3, 'sine', 0.3), i * 100);
                });
            },
            playGameOver() {
                [440, 330, 220, 110].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.4, 'sawtooth', 0.2), i * 150);
                });
            }
        };

        // ============================================
        // STORAGE SYSTEM - localStorage with Capacitor fallback
        // ============================================
        const Storage = {
            async get(key) {
                // Try Capacitor Preferences first
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
                    const result = await window.Capacitor.Plugins.Preferences.get({ key });
                    return result.value ? JSON.parse(result.value) : null;
                }
                // Fallback to localStorage
                try {
                    return JSON.parse(localStorage.getItem(key));
                } catch(e) {
                    return null;
                }
            },
            
            async set(key, value) {
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
                    await window.Capacitor.Plugins.Preferences.set({ key, value: JSON.stringify(value) });
                    return;
                }
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                } catch(e) {}
            },
            
            async remove(key) {
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
                    await window.Capacitor.Plugins.Preferences.remove({ key });
                    return;
                }
                localStorage.removeItem(key);
            }
        };

        // ============================================
        // HIGH SCORE SYSTEM
        // ============================================
        const HighScores = {
            KEY: 'hatebeat_scores',
            cache: null,
            
            async get() {
                if (this.cache) return this.cache;
                // Use NativeStorage if available (Capacitor), otherwise fallback
                const data = await (window.NativeStorage?.get(this.KEY) || Storage.get(this.KEY));
                this.cache = data || [];
                return this.cache;
            },
            
            async add(score, task, hateLevel, maxCombo, accuracy) {
                const scores = await this.get();
                scores.push({
                    score: Math.floor(score),
                    task: task.substring(0, 30),
                    hateLevel,
                    maxCombo,
                    accuracy,
                    date: new Date().toISOString()
                });
                scores.sort((a, b) => b.score - a.score);
                scores.splice(10);
                this.cache = scores;
                await (window.NativeStorage?.set(this.KEY, scores) || Storage.set(this.KEY, scores));
                return scores;
            },
            
            async getHighScore() {
                const scores = await this.get();
                return scores.length > 0 ? scores[0].score : 0;
            },
            
            async clear() {
                this.cache = [];
                await (window.NativeStorage?.remove(this.KEY) || Storage.remove(this.KEY));
            }
        };

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency
        let animationId;
        let lastTime = 0;
        let canvasScale = 1;

        function resizeCanvas() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2); // Limit DPR for performance
            canvasScale = dpr;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ============================================
        // NAVIGATION
        // ============================================
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screen = document.getElementById(id);
            if (screen) screen.classList.add('active');
        }

        function goToScreen2() {
            const task = document.getElementById('taskInput').value.trim();
            if (!task) return;
            gameState.task = task;
            document.getElementById('taskName').textContent = task;
            showScreen('screen2');
        }

        let selectedHate = 0;
        function selectHate(level) {
            selectedHate = level;
            document.querySelectorAll('.hate-btn').forEach((btn, i) => {
                btn.classList.toggle('selected', i < level);
            });
            const labels = ['', 'Mild annoyance', 'Slightly irritating', 'Bothersome', 
                          'Frustrating', 'Very annoying', 'Hate it', 'Strongly despise',
                          'Absolutely loathe', 'Pure rage', 'EXISTENTIAL DREAD'];
            document.getElementById('hateLabel').textContent = labels[level];
            document.getElementById('continueBtn2').disabled = false;
        }

        function goToScreen3() {
            if (!selectedHate) return;
            gameState.hateLevel = selectedHate;
            LevelSystem.renderGrid();
            showScreen('screen3');
        }
        
        let selectedLevel = null;
        function selectLevel(levelId) {
            const level = LevelSystem.getLevel(levelId);
            if (!level || !level.unlocked) return;
            
            selectedLevel = level;
            gameState.task = level.task;
            gameState.hateLevel = level.hateLevel;
            document.getElementById('hateWords').value = level.words;
            
            MobileUtils.haptic('medium');
            if (window.triggerHaptic) window.triggerHaptic('medium');
            
            startBattle();
        }

        // ============================================
        // WORD PARSING
        // ============================================
        function parseWords(text) {
            return text.toLowerCase()
                .replace(/[^a-z\s]/g, '')
                .split(/\s+/)
                .filter(w => w.length > 2)
                .slice(0, MobileUtils.isLowEnd ? 10 : 15);
        }

        // ============================================
        // ENEMY CLASS
        // ============================================
        class WordEnemy {
            constructor(word, index, total) {
                this.word = word;
                this.hp = Math.ceil(word.length / 2);
                this.maxHp = this.hp;
                
                // Spawn from edges
                const side = Math.floor(Math.random() * 4);
                const padding = 80;
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                switch(side) {
                    case 0: this.x = Math.random() * w; this.y = -padding; break;
                    case 1: this.x = w + padding; this.y = Math.random() * h; break;
                    case 2: this.x = Math.random() * w; this.y = h + padding; break;
                    case 3: this.x = -padding; this.y = Math.random() * h; break;
                }
                
                // Speed based on hate level
                const baseSpeed = 0.8 + (gameState.hateLevel * 0.4);
                const centerX = w / 2;
                const centerY = h / 2;
                const angle = Math.atan2(centerY - this.y, centerX - this.x);
                const speedVariation = 0.7 + Math.random() * 0.6;
                this.vx = Math.cos(angle) * baseSpeed * speedVariation;
                this.vy = Math.sin(angle) * baseSpeed * speedVariation;
                
                // Visual properties
                this.baseSize = 18 + word.length * 2.5;
                this.size = this.baseSize;
                this.hue = Math.random() * 40;
                this.shake = 0;
                this.spawnTime = Date.now();
                this.scale = 0;
                this.targetScale = 1;
                this.pulseOffset = Math.random() * Math.PI * 2;
            }

            update(deltaTime) {
                // Spawn animation
                if (this.scale < this.targetScale) {
                    this.scale += deltaTime * 0.003;
                    if (this.scale > this.targetScale) this.scale = this.targetScale;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Bounce off edges
                const padding = 60;
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                if (this.x < padding) { this.x = padding; this.vx *= -1; }
                if (this.x > w - padding) { this.x = w - padding; this.vx *= -1; }
                if (this.y < padding) { this.y = padding; this.vy *= -1; }
                if (this.y > h - padding) { this.y = h - padding; this.vy *= -1; }
                
                if (this.shake > 0) this.shake--;
                
                // Pulse with beat
                const beatPhase = (Date.now() % gameState.beatInterval) / gameState.beatInterval;
                this.size = this.baseSize * (1 + Math.sin(beatPhase * Math.PI * 2 + this.pulseOffset) * 0.1);
            }

            draw() {
                ctx.save();
                
                const shakeX = this.shake > 0 ? (Math.random() - 0.5) * 10 : 0;
                const shakeY = this.shake > 0 ? (Math.random() - 0.5) * 10 : 0;
                
                // Glow effect (reduced on low-end devices)
                if (!MobileUtils.isLowEnd) {
                    ctx.shadowColor = `hsl(${this.hue}, 80%, 60%)`;
                    ctx.shadowBlur = 20;
                }
                
                // Word text
                ctx.font = `bold ${this.size * this.scale}px sans-serif`;
                ctx.fillStyle = `hsl(${this.hue}, 80%, ${60 + Math.sin(Date.now() * 0.005) * 10}%)`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.word, this.x + shakeX, this.y + shakeY);
                
                // HP bar
                const barWidth = 70;
                const barHeight = 8;
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 18, barWidth, barHeight);
                ctx.fillStyle = `hsl(${120 * (this.hp/this.maxHp)}, 80%, 50%)`;
                ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 18, barWidth * (this.hp/this.maxHp), barHeight);
                
                ctx.restore();
            }

            checkHit(x, y) {
                const dist = Math.hypot(x - this.x, y - this.y);
                return dist < this.size * 1.5;
            }

            damage() {
                this.hp--;
                this.shake = 10;
                return this.hp <= 0;
            }
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 5;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.02;
                this.color = color;
                this.size = 3 + Math.random() * 5;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
                this.size *= 0.97;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function createParticles(x, y, hue) {
            const color = `hsl(${hue}, 80%, 60%)`;
            const count = MobileUtils.isLowEnd ? 8 : 15;
            for (let i = 0; i < count; i++) {
                gameState.particles.push(new Particle(x, y, color));
            }
        }

        // ============================================
        // FLOATING TEXT
        // ============================================
        function showFloatingText(x, y, text, type) {
            const el = document.createElement('div');
            el.className = `floating-text ${type}`;
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // ============================================
        // RHYTHM MECHANICS
        // ============================================
        function isOnBeat() {
            const now = Date.now();
            const beatPhase = (now % gameState.beatInterval) / gameState.beatInterval;
            return beatPhase < 0.3 || beatPhase > 0.7;
        }

        function getTimingQuality() {
            const now = Date.now();
            const beatPhase = (now % gameState.beatInterval) / gameState.beatInterval;
            const distFromBeat = Math.min(beatPhase, 1 - beatPhase);
            if (distFromBeat < 0.15) return 'perfect';
            if (distFromBeat < 0.3) return 'good';
            return 'miss';
        }

        function triggerBeat() {
            const indicator = document.getElementById('beatIndicator');
            indicator.classList.remove('active');
            void indicator.offsetWidth;
            indicator.classList.add('active');
        }

        // ============================================
        // GAME FUNCTIONS
        // ============================================
        function startBattle() {
            const hateText = document.getElementById('hateWords').value.trim();
            if (!hateText) return;
            
            gameState.words = parseWords(hateText);
            if (gameState.words.length === 0) {
                const input = document.getElementById('hateWords');
                input.setCustomValidity('Enter at least one word with 3 or more letters.');
                input.reportValidity();
                input.setCustomValidity('');
                MobileUtils.haptic('error');
                if (window.triggerHaptic) window.triggerHaptic('error');
                return;
            }
            gameState.totalWords = gameState.words.length;
            gameState.wordsDestroyed = 0;
            gameState.score = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.perfectHits = 0;
            gameState.totalHits = 0;
            gameState.particles = [];
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.gameTime = 0;
            
            // Beat interval based on hate level
            gameState.beatInterval = 600 - (gameState.hateLevel * 40);
            
            // Create enemies with staggered spawn
            gameState.enemies = [];
            gameState.words.forEach((word, i) => {
                setTimeout(() => {
                    if (gameState.isPlaying && !gameState.isPaused) {
                        gameState.enemies.push(new WordEnemy(word, i, gameState.words.length));
                        updateUI();
                    }
                }, i * 800);
            });
            
            updateUI();
            showScreen('');
            canvas.classList.add('active');
            document.getElementById('uiOverlay').classList.add('active');
            document.getElementById('rhythmBar').classList.add('active');
            document.getElementById('tutorial').classList.add('active');
            document.getElementById('pauseBtn').style.display = 'flex';
            
            setTimeout(() => {
                document.getElementById('tutorial').classList.remove('active');
            }, 5000);
            
            lastTime = performance.now();
            gameLoop(lastTime);
            
            // Haptic feedback
            MobileUtils.haptic('medium');
            
            // Also trigger native haptic if available
            if (window.triggerHaptic) {
                window.triggerHaptic('medium');
            }
        }

        function updateUI() {
            const remaining = gameState.enemies.length;
            const percent = gameState.totalWords > 0 ? (remaining / gameState.totalWords) * 100 : 0;
            document.getElementById('hpFill').style.width = percent + '%';
            document.getElementById('wordsRemaining').textContent = remaining;
            document.getElementById('scoreDisplay').textContent = 'Score: ' + Math.floor(gameState.score);
            
            const comboEl = document.getElementById('comboDisplay');
            if (gameState.combo > 1) {
                comboEl.textContent = 'Combo: x' + gameState.combo;
                comboEl.classList.add('active');
            } else {
                comboEl.classList.remove('active');
            }
        }

        function updateFPS(currentTime) {
            gameState.frameCount++;
            if (currentTime - gameState.lastFpsTime >= 1000) {
                gameState.fps = gameState.frameCount;
                gameState.frameCount = 0;
                gameState.lastFpsTime = currentTime;
                document.getElementById('fpsCounter').textContent = 'FPS: ' + gameState.fps;
            }
        }

        function gameLoop(currentTime) {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            gameState.gameTime += deltaTime;
            
            // Update FPS
            updateFPS(currentTime);
            
            // Trigger beat
            const beatNow = Math.floor(gameState.gameTime / gameState.beatInterval);
            const lastBeat = Math.floor((gameState.gameTime - deltaTime) / gameState.beatInterval);
            if (beatNow > lastBeat) {
                triggerBeat();
                AudioSys.playBeat();
            }
            
            // Clear canvas with trail effect
            ctx.fillStyle = 'rgba(26, 26, 46, 0.25)';
            ctx.fillRect(0, 0, canvas.width / canvasScale, canvas.height / canvasScale);
            
            // Update and draw enemies
            gameState.enemies.forEach(enemy => {
                enemy.update(deltaTime);
                enemy.draw();
            });
            
            // Update and draw particles (limit on low-end)
            const maxParticles = MobileUtils.isLowEnd ? 50 : 100;
            if (gameState.particles.length > maxParticles) {
                gameState.particles = gameState.particles.slice(-maxParticles);
            }
            gameState.particles = gameState.particles.filter(p => {
                p.update();
                p.draw();
                return p.life > 0;
            });
            
            // Check victory
            if (gameState.enemies.length === 0 && gameState.totalWords > 0) {
                victory();
                return;
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLING - Enhanced for mobile
        // ============================================
        function handleInput(clientX, clientY) {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left) * (canvas.width / rect.width) / canvasScale;
            const y = (clientY - rect.top) * (canvas.height / rect.height) / canvasScale;
            
            let hit = false;
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                if (gameState.enemies[i].checkHit(x, y)) {
                    hit = true;
                    const timing = getTimingQuality();
                    let points = 100;
                    let text = 'GOOD';
                    let type = 'good';
                    
                    if (timing === 'perfect') {
                        points = 200;
                        text = 'PERFECT!';
                        type = 'perfect';
                        gameState.perfectHits++;
                        gameState.combo++;
                        AudioSys.playPerfect();
                        MobileUtils.haptic('success');
                        if (window.triggerHaptic) window.triggerHaptic('success');
                    } else if (timing === 'good') {
                        points = 100;
                        gameState.combo++;
                        AudioSys.playGood();
                        MobileUtils.haptic('light');
                        if (window.triggerHaptic) window.triggerHaptic('light');
                    } else {
                        points = 50;
                        text = 'MISS';
                        type = 'miss';
                        gameState.combo = 0;
                        AudioSys.playMiss();
                        MobileUtils.haptic('error');
                        if (window.triggerHaptic) window.triggerHaptic('error');
                    }
                    
                    if (gameState.combo > gameState.maxCombo) {
                        gameState.maxCombo = gameState.combo;
                    }
                    
                    points *= (1 + gameState.combo * 0.1);
                    gameState.score += points;
                    gameState.totalHits++;
                    
                    showFloatingText(clientX, clientY, text + (gameState.combo > 1 ? ' x' + gameState.combo : ''), type);
                    
                    if (gameState.enemies[i].damage()) {
                        createParticles(gameState.enemies[i].x, gameState.enemies[i].y, gameState.enemies[i].hue);
                        AudioSys.playDestroy();
                        gameState.enemies.splice(i, 1);
                        gameState.wordsDestroyed++;
                        MobileUtils.haptic('medium');
                        if (window.triggerHaptic) window.triggerHaptic('medium');
                    } else {
                        AudioSys.playHit();
                    }
                    updateUI();
                    break;
                }
            }
            
            if (!hit) {
                gameState.combo = 0;
                updateUI();
                MobileUtils.haptic('error');
                if (window.triggerHaptic) window.triggerHaptic('error');
            }
        }

        // Touch/Click handlers with multi-touch support
        const activeTouches = new Map();
        
        canvas.addEventListener('click', (e) => {
            handleInput(e.clientX, e.clientY);
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                activeTouches.set(touch.identifier, { x: touch.clientX, y: touch.clientY });
                handleInput(touch.clientX, touch.clientY);
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                activeTouches.delete(e.changedTouches[i].identifier);
            }
        }, { passive: false });
        
        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (gameState.isPlaying) {
                e.preventDefault();
            }
        }, { passive: false });

        // ============================================
        // PAUSE SYSTEM
        // ============================================
        function togglePause() {
            if (!gameState.isPlaying) return;
            
            gameState.isPaused = !gameState.isPaused;
            const pauseMenu = document.getElementById('pauseMenu');
            
            if (gameState.isPaused) {
                pauseMenu.classList.add('active');
                cancelAnimationFrame(animationId);
            } else {
                pauseMenu.classList.remove('active');
                lastTime = performance.now();
                gameLoop(lastTime);
            }
            MobileUtils.haptic('light');
            if (window.triggerHaptic) window.triggerHaptic('light');
        }
        
        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseMenu').classList.remove('active');
            lastTime = performance.now();
            gameLoop(lastTime);
            MobileUtils.haptic('light');
            if (window.triggerHaptic) window.triggerHaptic('light');
        }

        // ============================================
        // VICTORY / GAME OVER
        // ============================================
        async function victory() {
            gameState.isPlaying = false;
            cancelAnimationFrame(animationId);
            
            const accuracy = gameState.totalHits > 0 
                ? Math.round((gameState.perfectHits / gameState.totalHits) * 100) 
                : 0;
            
            await HighScores.add(gameState.score, gameState.task, gameState.hateLevel, gameState.maxCombo, accuracy);
            
            // Unlock next level if playing a preset level
            let unlockedLevel = null;
            if (selectedLevel) {
                unlockedLevel = await LevelSystem.unlockNextLevel(selectedLevel.id);
            }
            
            AudioSys.playVictory();
            MobileUtils.haptic('success');
            if (window.triggerHaptic) window.triggerHaptic('success');
            
            document.getElementById('victoryTask').textContent = gameState.task;
            document.getElementById('finalScore').textContent = Math.floor(gameState.score);
            document.getElementById('maxCombo').textContent = gameState.maxCombo;
            document.getElementById('perfectHits').textContent = gameState.perfectHits;
            document.getElementById('accuracy').textContent = accuracy + '%';
            
            // Show unlock notification if applicable
            if (unlockedLevel) {
                const unlockMsg = document.createElement('div');
                unlockMsg.style.cssText = 'background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%); color: #000; padding: 10px 20px; border-radius: 20px; margin: 10px 0; font-weight: bold; animation: victoryPulse 1s ease-in-out infinite;';
                unlockMsg.textContent = `üîì Unlocked: ${unlockedLevel.name}`;
                document.getElementById('victoryScreen').insertBefore(unlockMsg, document.getElementById('victoryScreen').querySelector('button'));
            }
            
            document.getElementById('victoryScreen').classList.add('active');
            document.getElementById('pauseBtn').style.display = 'none';
        }

        function showGameOver() {
            gameState.isPlaying = false;
            cancelAnimationFrame(animationId);
            
            AudioSys.playGameOver();
            MobileUtils.haptic('error');
            if (window.triggerHaptic) window.triggerHaptic('error');
            
            document.getElementById('gameOverScore').textContent = Math.floor(gameState.score);
            document.getElementById('enemiesDestroyed').textContent = gameState.wordsDestroyed;
            document.getElementById('gameOverScreen').classList.add('active');
            document.getElementById('pauseBtn').style.display = 'none';
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function toggleSound() {
            AudioSys.enabled = !AudioSys.enabled;
            document.getElementById('soundToggle').textContent = AudioSys.enabled ? 'üîä' : 'üîá';
            MobileUtils.haptic('light');
            if (window.triggerHaptic) window.triggerHaptic('light');
        }

        function escapeHtml(value) {
            return String(value).replace(/[&<>"']/g, (char) => {
                const entities = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                };
                return entities[char];
            });
        }

        async function displayHighScores() {
            const scores = await HighScores.get();
            const badge = document.getElementById('highScoreBadge');
            const list = document.getElementById('highScoresList');
            
            if (scores.length === 0) {
                badge.style.display = 'none';
                list.style.display = 'none';
                return;
            }
            
            badge.style.display = 'block';
            document.getElementById('highScoreValue').textContent = scores[0].score;
            
            list.style.display = 'block';
            list.innerHTML = scores.slice(0, 5).map((s, i) => {
                const safeTask = escapeHtml(s.task || '');
                return `
                    <div class="high-score-item">
                        <span class="high-score-rank">#${i + 1}</span>
                        <span class="high-score-task" title="${safeTask}">${safeTask}</span>
                        <span class="high-score-points">${s.score}</span>
                    </div>
                `;
            }).join('');
        }

        function resetGame() {
            gameState.isPlaying = false;
            gameState.isPaused = false;
            cancelAnimationFrame(animationId);
            
            document.getElementById('victoryScreen').classList.remove('active');
            document.getElementById('gameOverScreen').classList.remove('active');
            document.getElementById('pauseMenu').classList.remove('active');
            canvas.classList.remove('active');
            document.getElementById('uiOverlay').classList.remove('active');
            document.getElementById('rhythmBar').classList.remove('active');
            document.getElementById('tutorial').classList.remove('active');
            document.getElementById('comboDisplay').classList.remove('active');
            document.getElementById('pauseBtn').style.display = 'none';
            
            // Reset state
            gameState = {
                task: '',
                hateLevel: 0,
                words: [],
                enemies: [],
                particles: [],
                floatingTexts: [],
                wordsDestroyed: 0,
                totalWords: 0,
                score: 0,
                combo: 0,
                maxCombo: 0,
                perfectHits: 0,
                totalHits: 0,
                lastBeatTime: 0,
                beatInterval: 500,
                isPlaying: false,
                isPaused: false,
                gameTime: 0,
                soundEnabled: gameState.soundEnabled,
                fps: 60,
                frameCount: 0,
                lastFpsTime: 0
            };
            
            // Reset UI
            document.getElementById('taskInput').value = '';
            document.getElementById('hateWords').value = '';
            document.querySelectorAll('.hate-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('hateLabel').textContent = '';
            document.getElementById('continueBtn2').disabled = true;
            selectedHate = 0;
            selectedLevel = null;
            
            // Remove any unlock notifications
            const unlockMsgs = document.querySelectorAll('#victoryScreen div[style*="ffd700"]');
            unlockMsgs.forEach(msg => msg.remove());
            
            displayHighScores();
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width / canvasScale, canvas.height / canvasScale);
            showScreen('screen1');
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        
        // Initialize audio on first interaction
        function initAudio() {
            AudioSys.init();
            document.removeEventListener('click', initAudio);
            document.removeEventListener('touchstart', initAudio);
        }
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });
        
        // Handle visibility change
        MobileUtils.handleVisibility(gameState, togglePause);

        let lastBackPressTime = 0;
        function handleBackButton() {
            const now = Date.now();
            if (now - lastBackPressTime < 250) return true;
            lastBackPressTime = now;

            if (gameState.isPlaying) {
                togglePause();
                return true;
            }

            if (document.getElementById('screenCustom').classList.contains('active')) {
                showScreen('screen3');
                return true;
            }
            if (document.getElementById('screen3').classList.contains('active')) {
                showScreen('screen2');
                return true;
            }
            if (document.getElementById('screen2').classList.contains('active')) {
                showScreen('screen1');
                return true;
            }

            return false;
        }
        window.handleBackButton = handleBackButton;
        
        // Handle back button on Android
        document.addEventListener('backbutton', (e) => {
            if (handleBackButton()) {
                e.preventDefault();
            }
        }, false);
        
        // Load high scores on page load
        window.addEventListener('load', async () => {
            await LevelSystem.getUnlockedLevels();
            displayHighScores();
        });

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (document.getElementById('screen1').classList.contains('active')) {
                    goToScreen2();
                } else if (document.getElementById('screenCustom').classList.contains('active')) {
                    startBattle();
                }
            } else if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                if (gameState.isPlaying) {
                    togglePause();
                }
            }
        });
        
        // Prevent zoom on iOS
        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());
        document.addEventListener('gestureend', (e) => e.preventDefault());
    </script>
</body>
</html>
